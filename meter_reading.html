<!DOCTYPE html>
<html>
<head>
  <title>検針情報</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script charset="utf-8" src="https://static.worksmobile.net/static/wm/woff/edge/3.6.2/sdk.js"></script>
  <link rel="stylesheet" href="style.css">
  <style>
    body { font-family: sans-serif; margin: 10px; }
    .info-section { margin-bottom: 20px; }
    .info-section h2 { margin-top: 0; border-bottom: 1px solid #ccc; padding-bottom: 5px; }
    .info-item { margin-bottom: 8px; }
    .info-label { font-weight: bold; }
    #meter-readings-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    #meter-readings-table th, #meter-readings-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    #meter-readings-table th { background-color: #f2f2f2; }
    /* モーダルのスタイル */
    #photo-modal {
      display: none; /* 初めは非表示 */
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.8); /* 半透明の黒 */
    }

    #modal-content {
      position: relative;
      margin: 15% auto;
      padding: 20px;
      width: 80%;
      max-width: 700px;
      background-color: #fff;
      border-radius: 8px;
    }

    #modal-image {
      width: 100%;
      height: auto;
      border-radius: 4px;
    }

    .close-modal-button {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      font-size: 18px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <button id="back-button-meter" style="margin-bottom: 10px; padding: 8px 12px;">部屋選択へ戻る</button>
  <h1>検針情報</h1>
  <div id="debug-info" style="border: 1px solid red; padding: 10px; margin-top: 10px; white-space: pre-wrap; font-size: 10px; background-color: #f0f0f0; color: black;">デバッグ情報エリア</div>

  <div class="info-section">
    <h2>物件・部屋情報</h2>
    <div class="info-item">
        <span class="info-label">物件名:</span> <span id="property-name"></span> /
        <span class="info-label">部屋名:</span> <span id="room-name"></span>
    </div>
    <div class="info-item" style="display: none;"><span class="info-label">物件ID:</span> <span id="property-id"></span></div>
    <div class="info-item" style="display: none;"><span class="info-label">部屋ID:</span> <span id="room-id"></span></div>
  </div>

  <div class="info-section">
    <h2>検針履歴</h2>
    <div id="meter-readings-list">
      <p id="loading-message-p">検針データを読み込み中です...</p>
      <table id="meter-readings-table" style="display:none;">
        <thead>
          <tr>
            <th>検針日時</th>
            <th>今回(㎥)</th>
            <th>前回</th>
            <th>前々回</th>
            <th>今回使用量</th>
            <th>状態</th>
            <th>写真</th>
          </tr>
        </thead>
        <tbody>
          <!-- ここに検針データが挿入されます -->
        </tbody>
      </table>
      <button id="update-readings-button" style="margin-top: 10px; padding: 8px 12px; display:none;">指示数を更新</button> <!-- 更新ボタン追加 -->
      <p id="no-data-message" style="display:none; color:red;"></p>
    </div>
  </div>

  <!-- 写真表示モーダル -->
  <div id="photo-modal">
    <div id="modal-content">
      <button class="close-modal-button">&times;</button>
      <img id="modal-image" alt="検針写真"> <!-- src属性を削除 -->
    </div>
  </div>

  <script>
    const woffIdForWorks = "Mtmj4rddmxBddYCPD0G81A"; // これは適切なWOFF IDに置き換えてください
    let gasWebAppUrl; // sessionStorageから取得するとして宣言

    // モーダル関連の変数をグローバルスコープで宣言 (ただし初期化はDOMContentLoaded内)
    let photoModal, modalImage, closeModalButton;

    // 戻るボタンの共通処理
    function handleBackButton() {
      // room_select.html に遷移する
      window.location.href = 'room_select.html';
    }

    async function initializeWoff() {
      try {
        console.log('[meter_reading] WOFFを初期化します。');
        const debugInfoDiv = document.getElementById('debug-info');
        debugInfoDiv.innerHTML = 'WOFF初期化開始...<br>';

        // sessionStorageからgasWebAppUrlを取得
        gasWebAppUrl = sessionStorage.getItem('gasWebAppUrl');
        if (!gasWebAppUrl) {
          console.error('[meter_reading] gasWebAppUrlがsessionStorageから取得できませんでした。');
          document.getElementById('meter-readings-list').innerHTML = '<p>アプリの設定情報が不足しています。前の画面から再度操作してください。</p>';
          return; // gasWebAppUrlがないと続行不可
        }
        console.log('[meter_reading] gasWebAppUrlをsessionStorageから取得しました:', gasWebAppUrl);

        if (typeof woff === 'undefined' || typeof woff.init !== 'function') {
          console.error('[meter_reading] WOFF SDKが正しく読み込まれていません。');
          document.getElementById('meter-readings-list').innerHTML = '<p>アプリの起動に必要なコンポーネントが読み込めませんでした。</p>';
          return; // WOFFが利用できない場合は初期化処理を中断
        }
        await woff.init({ woffId: woffIdForWorks });
        console.log('[meter_reading] WOFFの初期化に成功しました。');
        debugInfoDiv.innerHTML += 'WOFF初期化成功。<br>';
        // WOFF初期化成功直後のwoffオブジェクトの状態を確認
        console.log('[meter_reading] WOFF初期化成功直後のwoffオブジェクト全体:', woff);
        debugInfoDiv.innerHTML += '<b>WOFF初期化直後:</b><br>';
        if (woff) {
            console.log('[meter_reading] woffのプロパティ一覧:', Object.keys(woff));
            debugInfoDiv.innerHTML += 'woffオブジェクトのプロパティ: ' + JSON.stringify(Object.keys(woff)) + '<br>';
            console.log('[meter_reading] WOFF初期化成功直後のwoff.media:', woff.media);
            debugInfoDiv.innerHTML += 'woff.media: ' + String(woff.media) + '<br>';
            if (woff.media) {
                debugInfoDiv.innerHTML += 'woff.mediaのプロパティ: ' + JSON.stringify(Object.keys(woff.media)) + '<br>';
            } else {
                debugInfoDiv.innerHTML += 'woff.media は undefined または null です。<br>';
            }
        } else {
            debugInfoDiv.innerHTML += 'woff オブジェクト自体が undefined または null です。<br>';
        }
        // WOFF初期化成功後にメインの処理を実行
        await loadMeterReadings();
      } catch (error) {
        console.error('[meter_reading] WOFFの初期化に失敗しました:', error);
        const debugInfoDiv = document.getElementById('debug-info');
        if (debugInfoDiv) {
            debugInfoDiv.innerHTML += '<b>WOFF初期化失敗:</b> ' + error.toString() + '<br>';
        }
        document.getElementById('meter-readings-list').innerHTML = '<p>アプリの起動に失敗しました。WOFFの初期化を確認してください。</p>';
        // WOFF初期化失敗時も、loadMeterReadings を試みるか、あるいはエラー表示のみとするか。
        // 現状はエラー表示のみで、戻るボタンは機能する。
        // loadMeterReadings(); // WOFFなしで続行する場合（ただしWOFF依存機能は使えない）
      }
    }

    async function loadMeterReadings() {
      const urlParams = new URLSearchParams(window.location.search);
      const propertyId = urlParams.get('propertyId');
      const propertyName = urlParams.get('propertyName');
      const roomId = urlParams.get('roomId');
      const roomName = urlParams.get('roomName');

      document.getElementById('property-id').textContent = propertyId || 'N/A';
      document.getElementById('property-name').textContent = propertyName || 'N/A';
      document.getElementById('room-id').textContent = roomId || 'N/A';
      document.getElementById('room-name').textContent = roomName || 'N/A';

      // Get references to the elements
      const loadingElement = document.getElementById('loading-message-p');
      const tableElement = document.getElementById('meter-readings-table');
      const tableBody = tableElement.getElementsByTagName('tbody')[0];
      const noDataMessageElement = document.getElementById('no-data-message');

      // Initial state: Show loading, hide table and no-data message
      if (loadingElement) loadingElement.style.display = 'block';
      tableElement.style.display = 'none';
      noDataMessageElement.style.display = 'none';

      if (!propertyId || !roomId) {
        console.error('[meter_reading] 物件IDまたは部屋IDがURLパラメータにありません。');
        if (loadingElement) loadingElement.style.display = 'none'; // Hide loading
        noDataMessageElement.textContent = '物件情報または部屋情報が不足しているため、検針データを取得できません。';
        noDataMessageElement.style.display = 'block';
        tableElement.style.display = 'none'; // Ensure table is hidden
        return;
      }

      try {
        const response = await fetch(`${gasWebAppUrl}?action=getMeterReadings&propertyId=${propertyId}&roomId=${roomId}`);
        if (!response.ok) {
          throw new Error('ネットワークの応答が正しくありませんでした。ステータス: ' + response.status);
        }
        const readings = await response.json();

        if (loadingElement) loadingElement.style.display = 'none'; // Always hide loading message after fetch attempt

        if (readings.error) {
          // Let the catch block handle the display of the error message
          throw new Error(readings.error);
        }
        
        console.log('[meter_reading] Fetched meter readings:', readings);

        if (Array.isArray(readings) && readings.length > 0) {
          tableElement.style.display = ''; // Show table
          document.getElementById('update-readings-button').style.display = 'block'; // 更新ボタン表示
          noDataMessageElement.style.display = 'none'; // Hide no-data message
          tableBody.innerHTML = ''; // 古いデータをクリア

          readings.forEach(reading => {
            const row = tableBody.insertRow();
            
            // 日付フォーマット処理
            let formattedDate = 'N/A';
            if (reading.date) {
              try {
                const dateObj = new Date(reading.date);
                // getTimezoneOffset() を使用してUTCとの差分を考慮し、JSTに近づける
                // ただし、GASから返る日付が既にJSTである場合は、このオフセット調整は不要または逆効果になる可能性あり
                // スプレッドシートの日時がどのように記録・返却されるかに依存
                // ここでは一旦、Dateオブジェクトがローカルタイムゾーンで解釈されることを期待する
                // もしGASがUTCで日付時刻を返し、表示時にJSTにしたい場合は、より厳密なタイムゾーン変換が必要
                const year = dateObj.getFullYear();
                const month = (dateObj.getMonth() + 1).toString().padStart(2, '0'); // 月は0から始まるため+1
                const day = dateObj.getDate().toString().padStart(2, '0');
                if (!isNaN(year) && !isNaN(parseInt(month)) && !isNaN(parseInt(day))) {
                  formattedDate = `${year}年${month}月${day}日`;
                } else {
                  // パースに失敗した場合、元の値をそのまま使うか、エラーを示す文字列にする
                  // ここでは元の値を使用
                  formattedDate = reading.date; 
                }
              } catch (e) {
                console.warn('[meter_reading] 日付のフォーマットに失敗しました:', reading.date, e);
                formattedDate = reading.date; // エラー時も元の値を表示
              }
            }
            row.insertCell().textContent = formattedDate;
            
            // 今回指示数を入力フィールドに変更
            const currentReadingCell = row.insertCell();
            const currentReadingInput = document.createElement('input');
            currentReadingInput.type = 'number';
            currentReadingInput.value = reading.currentReading || '';
            currentReadingInput.setAttribute('data-date', reading.date); // 識別子として日付を使用
            currentReadingInput.setAttribute('pattern', '[0-9]*'); // 数字のみを許可するパターン
            currentReadingInput.setAttribute('inputmode', 'numeric'); // 数字キーボードを表示
            currentReadingInput.style.width = '80px'; // スタイル調整

            // 数字以外の入力を防ぐイベントリスナーを追加
            currentReadingInput.addEventListener('input', function(e) {
              e.target.value = e.target.value.replace(/[^0-9]/g, '');
            });

            currentReadingCell.appendChild(currentReadingInput);

            row.insertCell().textContent = reading.previousReading || 'N/A';
            row.insertCell().textContent = reading.previousPreviousReading || 'N/A'; // 追加
            row.insertCell().textContent = reading.usage || 'N/A';
            row.insertCell().textContent = reading.status || 'N/A';
            const photoCell = row.insertCell();
            photoCell.setAttribute('data-date-photo', reading.date); // 写真セルにも日付を紐付け

            // 既存の画像表示ロジック
            if (reading.photoUrl) {
              const img = document.createElement('img');
              img.src = reading.photoUrl;
              img.alt = '検針写真';
              img.style.maxWidth = '50px'; // 少し小さく調整
              img.style.maxHeight = '50px';
              img.style.cursor = 'pointer';
              img.addEventListener('click', () => showPhotoModal(reading.photoUrl));
              photoCell.appendChild(img);
            } else {
              // photoCell.textContent = 'なし'; // 「なし」の代わりにボタンを配置
            }

            // カメラボタンの作成
            const cameraButton = document.createElement('button');
            cameraButton.textContent = '撮影';
            cameraButton.setAttribute('data-date-button', reading.date);
            cameraButton.addEventListener('click', async (event) => {
              const debugInfoDiv = document.getElementById('debug-info');
              debugInfoDiv.innerHTML = 'カメラボタンクリック時のデバッグ情報:<br>'; // 情報をクリアして新しい情報を表示
              try {
                const date = event.target.getAttribute('data-date-button');
                console.log('[meter_reading] カメラボタンクリック (HTML Media Capture): date=', date);
                debugInfoDiv.innerHTML += 'カメラボタンクリック (HTML Media Capture): date=' + date + '<br>';

                // ファイル入力要素を動的に作成
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'image/*';
                fileInput.capture = 'environment'; // 'user' for front camera, 'environment' for back camera
                fileInput.style.display = 'none';

                fileInput.onchange = (e) => {
                  const file = e.target.files[0];
                  if (file) {
                    console.log('[meter_reading] ファイルが選択されました:', file.name);
                    debugInfoDiv.innerHTML += 'ファイル選択: ' + file.name + '<br>';
                    const reader = new FileReader();
                    reader.onload = (readerEvent) => {
                      const imageData = readerEvent.target.result; // Base64データ
                      console.log('[meter_reading] 画像データ (Base64) を取得しました。');
                      debugInfoDiv.innerHTML += '画像データをBase64で取得。<br>';

                      // 該当行の写真セルを特定
                      const targetPhotoCell = document.querySelector(`td[data-date-photo="${date}"]`);
                      if (targetPhotoCell) {
                        targetPhotoCell.innerHTML = ''; // 既存の内容をクリア

                        // 撮影した画像のプレビュー（小さい画像）
                        const newImg = document.createElement('img');
                        newImg.src = imageData;
                        newImg.alt = '撮影した写真';
                        newImg.style.maxWidth = '50px';
                        newImg.style.maxHeight = '50px';
                        newImg.style.cursor = 'pointer';
                        newImg.addEventListener('click', () => showPhotoModal(imageData));
                        targetPhotoCell.appendChild(newImg);

                        // 表示ボタンの作成
                        const viewButton = document.createElement('button');
                        viewButton.textContent = '表示';
                        viewButton.style.marginLeft = '5px';
                        viewButton.addEventListener('click', () => showPhotoModal(imageData));
                        targetPhotoCell.appendChild(viewButton);

                        // 再撮影ボタンの作成 (元のカメラボタンのイベントを再利用するのではなく、再度fileInputをクリックさせる)
                        const retakeButton = document.createElement('button');
                        retakeButton.textContent = '再撮影';
                        retakeButton.style.marginLeft = '5px';
                        retakeButton.addEventListener('click', () => {
                            // 元のカメラボタンのイベントリスナーを直接呼び出すのではなく、
                            // fileInputを再度トリガーする方がシンプルで確実
                            fileInput.click(); 
                        });
                        targetPhotoCell.appendChild(retakeButton);

                        // 撮影した画像データをinput要素に紐付ける
                        const currentReadingInput = document.querySelector(`#meter-readings-table tbody input[data-date="${date}"]`);
                        if (currentReadingInput) {
                          currentReadingInput.setAttribute('data-new-photo', imageData);
                          console.log('[meter_reading] 写真データをdata-new-photo属性に保存しました。');
                          debugInfoDiv.innerHTML += '写真データをdata-new-photo属性に保存。<br>';
                        }
                      }
                    };
                    reader.onerror = (error) => {
                        console.error('[meter_reading] FileReaderエラー:', error);
                        debugInfoDiv.innerHTML += '<span style="color: red;">FileReaderエラー: ' + error.toString() + '</span><br>';
                        alert('写真ファイルの読み込みに失敗しました。');
                    };
                    reader.readAsDataURL(file);
                  } else {
                    console.log('[meter_reading] ファイルは選択されませんでした。');
                    debugInfoDiv.innerHTML += 'ファイルは選択されませんでした。<br>';
                  }
                  // 使用後にファイル入力要素を削除 (連続して同じファイルを選択できるようにするため)
                  document.body.removeChild(fileInput);
                };
                
                // ファイル入力要素をDOMに追加してクリックイベントを発火
                document.body.appendChild(fileInput);
                fileInput.click();

              } catch (error) {
                console.error('[meter_reading] 写真の取得または処理に失敗しました (HTML Media Capture):', error);
                debugInfoDiv.innerHTML += '<span style="color: red;">写真処理エラー: ' + error.toString() + '</span><br>';
                alert('写真の処理中に予期せぬエラーが発生しました。');
                // エラーが発生した場合も、作成された可能性のあるfileInputを削除
                const orphanInput = document.querySelector('input[type="file"][style*="display: none"]');
                if (orphanInput && orphanInput.parentElement === document.body) {
                    document.body.removeChild(orphanInput);
                }
              }
            });
            photoCell.appendChild(cameraButton);


          });
        } else { // No data (readings is empty array or not an array)
          noDataMessageElement.textContent = 'この部屋の検針データはありません。';
          noDataMessageElement.style.display = 'block';
          tableElement.style.display = 'none'; // Ensure table is hidden
          document.getElementById('update-readings-button').style.display = 'none'; // 更新ボタン非表示
        }
      } catch (error) {
        console.error('[meter_reading] fetchMeterReadings error:', error);
        if (loadingElement) loadingElement.style.display = 'none'; // Hide loading message on error
        noDataMessageElement.textContent = `検針データの取得に失敗しました: ${error.message}`;
        noDataMessageElement.style.display = 'block';
        tableElement.style.display = 'none'; // Ensure table is hidden
        document.getElementById('update-readings-button').style.display = 'none'; // 更新ボタン非表示
      }
    }

    // 指示数更新ボタンの処理
    async function handleUpdateReadings() {
      const urlParams = new URLSearchParams(window.location.search);
      const propertyId = urlParams.get('propertyId');
      const roomId = urlParams.get('roomId');

      if (!propertyId || !roomId) {
        alert('物件IDまたは部屋IDが取得できませんでした。');
        return;
      }

      const inputs = document.querySelectorAll('#meter-readings-table tbody input[type="number"][data-date]');
      const updatedReadings = [];
      inputs.forEach(input => {
        const date = input.getAttribute('data-date');
        const newPhotoData = input.getAttribute('data-new-photo'); // 新しく撮影した写真のデータを取得
        updatedReadings.push({
          date: date,
          currentReading: input.value,
          photoData: newPhotoData || null // 写真データがない場合はnull
        });
        // 送信後にクリアするならここで
        // input.removeAttribute('data-new-photo'); 
      });

      if (updatedReadings.length === 0) {
        alert('更新するデータがありません。');
        return;
      }

      console.log('[meter_reading] 更新する指示数:', updatedReadings);
      console.log('[meter_reading] 送信先URL:', gasWebAppUrl); // 送信先URLをログに出力

      try {
        const response = await fetch(gasWebAppUrl, { 
          method: 'POST',
          headers: {
            'Content-Type': 'text/plain;charset=utf-8', 
          },
          body: JSON.stringify({ 
            action: 'updateMeterReadings',
            propertyId: propertyId,
            roomId: roomId,
            readings: updatedReadings
          }),
        });

        console.log('[meter_reading] Update response status:', response.status);

        const resultText = await response.text(); 
        console.log('[meter_reading] Update result text:', resultText);

        if (!response.ok) {
          throw new Error(resultText || 'ネットワークの応答が正しくありませんでした。ステータス: ' + response.status);
        }
        
        try {
            const result = JSON.parse(resultText); 
            if (result.success) {
              alert('指示数を更新しました。');
              await loadMeterReadings(); 
            } else {
              throw new Error(result.error || '指示数の更新に失敗しました。');
            }
        } catch (e) {
            throw new Error('サーバーからの応答形式が不正です: ' + resultText);
        }

      } catch (error) {
        console.error('[meter_reading] handleUpdateReadings error:', error);
        alert(`指示数の更新中にエラーが発生しました: ${error.message}`);
      }
    }

    // DOMContentLoaded ですべての初期化とイベントリスナー設定を行う
    document.addEventListener('DOMContentLoaded', async () => {
      // モーダル関連の要素をここで取得・初期化
      photoModal = document.getElementById('photo-modal');
      modalImage = document.getElementById('modal-image');
      closeModalButton = document.querySelector('.close-modal-button');

      if (closeModalButton) {
        closeModalButton.addEventListener('click', hidePhotoModal);
      }

      if (photoModal) {
        // モーダルの背景クリックで閉じる
        photoModal.addEventListener('click', function(event) {
          if (event.target === photoModal) { // クリックされたのが背景自身である場合のみ
            hidePhotoModal();
          }
        });
      }

      // 戻るボタンのイベントリスナーを一度だけ設定
      const backButton = document.getElementById('back-button-meter');
      if (backButton) {
        backButton.addEventListener('click', handleBackButton);
      }

      // 更新ボタンのイベントリスナーを設定
      const updateButton = document.getElementById('update-readings-button');
      if (updateButton) {
        updateButton.addEventListener('click', handleUpdateReadings);
      }
      
      // HTML Media Capture用のファイル入力要素のイベントリスナー
      const photoInput = document.getElementById('photo-input');
      if (photoInput) {
        photoInput.addEventListener('change', async function(event) {
          const targetDate = this.getAttribute('data-current-target-date');
          if (!targetDate) {
            console.error('[meter_reading] 対象の日付がphoto-inputから取得できませんでした。');
            return;
          }
          const file = event.target.files[0];
          if (file) {
            console.log('[meter_reading] ファイルが選択されました:', file.name, '対象日付:', targetDate);
            try {
              const imageData = await readFileAsBase64(file);
              console.log('[meter_reading] Base64変換成功。');

              const targetPhotoCell = document.querySelector(`td[data-date-photo="${targetDate}"]`);
              if (targetPhotoCell) {
                targetPhotoCell.innerHTML = ''; // 既存の内容をクリア

                // 撮影した画像のプレビュー（小さい画像）
                const newImg = document.createElement('img');
                newImg.src = imageData;
                newImg.alt = '撮影した写真';
                newImg.style.maxWidth = '50px';
                newImg.style.maxHeight = '50px';
                newImg.style.cursor = 'pointer';
                newImg.addEventListener('click', () => showPhotoModal(imageData));
                targetPhotoCell.appendChild(newImg);

                // 表示ボタンの作成
                const viewButton = document.createElement('button');
                viewButton.textContent = '表示';
                viewButton.style.marginLeft = '5px';
                viewButton.addEventListener('click', () => showPhotoModal(imageData));
                targetPhotoCell.appendChild(viewButton);

                // 再撮影ボタンの作成 (元のカメラボタンのイベントを再利用するのではなく、再度fileInputをクリックさせる)
                const retakeButton = document.createElement('button');
                retakeButton.textContent = '再撮影';
                retakeButton.style.marginLeft = '5px';
                retakeButton.addEventListener('click', () => {
                    // 元のカメラボタンのイベントリスナーを直接呼び出すのではなく、
                    // fileInputを再度トリガーする方がシンプルで確実
                    fileInput.click(); 
                });
                targetPhotoCell.appendChild(retakeButton);

                // 撮影した画像データをinput要素に紐付ける
                const currentReadingInput = document.querySelector(`#meter-readings-table tbody input[data-date="${targetDate}"]`);
                if (currentReadingInput) {
                  currentReadingInput.setAttribute('data-new-photo', imageData);
                  console.log('[meter_reading] 写真データをdata-new-photo属性に保存しました。');
                }
              }
            } catch (error) {
              console.error('[meter_reading] 写真のBase64変換に失敗しました:', error);
              alert('写真の処理中にエラーが発生しました。');
            }
          }
        });
      }

      // WOFF初期化処理を開始
      initializeWoff();
    });

    // ファイルをBase64として読み込むユーティリティ関数
    function readFileAsBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          resolve(e.target.result);
        };
        reader.onerror = (error) => {
          reject(error);
        };
        reader.readAsDataURL(file);
      });
    }

    // 写真をモーダルで表示する関数
    function showPhotoModal(imageData) {
      // DOMContentLoadedで初期化されるが、念のためチェック
      if (!photoModal) photoModal = document.getElementById('photo-modal');
      if (!modalImage) modalImage = document.getElementById('modal-image');

      if (photoModal && modalImage) {
        modalImage.src = imageData;
        photoModal.style.display = 'block';
      } else {
        console.error('[meter_reading] モーダル要素が見つかりません。');
      }
    }

    // モーダルを閉じる関数
    function hidePhotoModal() {
      if (!photoModal) photoModal = document.getElementById('photo-modal'); //念のため
      if (photoModal) {
        photoModal.style.display = 'none';
        if (modalImage) {
            modalImage.src = ''; // 次回表示のためにクリア
        }
      }
    }

    // DOMContentLoaded ですべての初期化とイベントリスナー設定を行う
    document.addEventListener('DOMContentLoaded', async () => {
      // モーダル関連の要素をここで取得・初期化
      photoModal = document.getElementById('photo-modal');
      modalImage = document.getElementById('modal-image');
      closeModalButton = document.querySelector('.close-modal-button');

      if (closeModalButton) {
        closeModalButton.addEventListener('click', hidePhotoModal);
      }

      if (photoModal) {
        // モーダルの背景クリックで閉じる
        photoModal.addEventListener('click', function(event) {
          if (event.target === photoModal) { // クリックされたのが背景自身である場合のみ
            hidePhotoModal();
          }
        });
      }

      // 戻るボタンのイベントリスナーを一度だけ設定
      const backButton = document.getElementById('back-button-meter');
      if (backButton) {
        backButton.addEventListener('click', handleBackButton);
      }

      // 更新ボタンのイベントリスナーを設定
      const updateButton = document.getElementById('update-readings-button');
      if (updateButton) {
        updateButton.addEventListener('click', handleUpdateReadings);
      }
      
      // HTML Media Capture用のファイル入力要素のイベントリスナー
      const photoInput = document.getElementById('photo-input');
      if (photoInput) {
        photoInput.addEventListener('change', async function(event) {
          const targetDate = this.getAttribute('data-current-target-date');
          if (!targetDate) {
            console.error('[meter_reading] 対象の日付がphoto-inputから取得できませんでした。');
            return;
          }
          const file = event.target.files[0];
          if (file) {
            console.log('[meter_reading] ファイルが選択されました:', file.name, '対象日付:', targetDate);
            try {
              const imageData = await readFileAsBase64(file);
              console.log('[meter_reading] Base64変換成功。');

              const targetPhotoCell = document.querySelector(`td[data-date-photo="${targetDate}"]`);
              if (targetPhotoCell) {
                targetPhotoCell.innerHTML = ''; // 既存の内容をクリア

                // 撮影した画像のプレビュー（小さい画像）
                const newImg = document.createElement('img');
                newImg.src = imageData;
                newImg.alt = '撮影した写真';
                newImg.style.maxWidth = '50px';
                newImg.style.maxHeight = '50px';
                newImg.style.cursor = 'pointer';
                newImg.addEventListener('click', () => showPhotoModal(imageData));
                targetPhotoCell.appendChild(newImg);

                // 表示ボタンの作成
                const viewButton = document.createElement('button');
                viewButton.textContent = '表示';
                viewButton.style.marginLeft = '5px';
                viewButton.addEventListener('click', () => showPhotoModal(imageData));
                targetPhotoCell.appendChild(viewButton);

                // 再撮影ボタンの作成 (元のカメラボタンのイベントを再利用するのではなく、再度fileInputをクリックさせる)
                const retakeButton = document.createElement('button');
                retakeButton.textContent = '再撮影';
                retakeButton.style.marginLeft = '5px';
                retakeButton.addEventListener('click', () => {
                    // 元のカメラボタンのイベントリスナーを直接呼び出すのではなく、
                    // fileInputを再度トリガーする方がシンプルで確実
                    fileInput.click(); 
                });
                targetPhotoCell.appendChild(retakeButton);

                // 撮影した画像データをinput要素に紐付ける
                const currentReadingInput = document.querySelector(`#meter-readings-table tbody input[data-date="${targetDate}"]`);
                if (currentReadingInput) {
                  currentReadingInput.setAttribute('data-new-photo', imageData);
                  console.log('[meter_reading] 写真データをdata-new-photo属性に保存しました。');
                }
              }
            } catch (error) {
              console.error('[meter_reading] 写真のBase64変換に失敗しました:', error);
              alert('写真の処理中にエラーが発生しました。');
            }
          }
        });
      }

      // WOFF初期化処理を開始
      initializeWoff();
    });
  </script>
</body>
</html>
