<!DOCTYPE html>
<html lang="ja">
<head>
  <title>部屋選択 - 水道メーター読み取りアプリ</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- PWA メタタグ -->
  <meta name="description" content="水道メーターの読み取りを管理するアプリケーション">
  <meta name="theme-color" content="#007bff">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="メーター読み取り">
  <meta name="msapplication-TileColor" content="#007bff">
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.json">
  
  <!-- Favicon and Icons -->
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iNCIgZmlsbD0iIzAwN2JmZiIvPgo8c3ZnIHg9IjgiIHk9IjgiIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJ3aGl0ZSI+CjxwYXRoIGQ9Ik0xMiAyQzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBTMTcuNTIgMiAxMiAyem0tMiAxNWwtNS01IDEuNDEtMS40MUwxMCAxNC4xN2w3LjU5LTcuNTlMMTkgOGwtOSA5eiIvPgo8L3N2Zz4KPC9zdmc+">
  <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDE4MCAxODAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxODAiIGhlaWdodD0iMTgwIiByeD0iMjAiIGZpbGw9IiMwMDdiZmYiLz4KPHN2ZyB4PSI0NSIgeT0iNDUiIHdpZHRoPSI5MCIgaGVpZ2h0PSI5MCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJ3aGl0ZSI+CjxwYXRoIGQ9Ik0xMiAyQzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBTMTcuNTIgMiAxMiAyem0tMiAxNWwtNS01IDEuNDEtMS40MUwxMCAxNC4xN2w3LjU5LTcuNTlMMTkgOGwtOSA5eiIvPgo8L3N2Zz4KPC9zdmc+">
  
  <!-- WOFF SDK removed for general browser compatibility -->
  
  <!-- クリティカルCSS (インライン) - 初回表示の改善 -->
  <style>
    /* Critical CSS for immediate styling */
    * { box-sizing: border-box; }
    body { 
      margin: 0; padding: 0; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      line-height: 1.6; background-color: #f5f5f5;
    }
    #root {
      min-height: 100vh;
      background-color: #f5f5f5;
    }
    .loading-container { 
      display: flex; align-items: center; justify-content: center; 
      min-height: 100vh; background-color: #f5f5f5; 
    }
    .loading-spinner { 
      width: 40px; height: 40px; border: 4px solid #e1e1e1; 
      border-top: 4px solid #007bff; border-radius: 50%; 
      animation: spin 1s linear infinite; 
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .mantine-container { 
      width: 100%; max-width: 1200px; margin: 0 auto; padding: 16px; 
    }
    .mantine-stack {
      display: flex; flex-direction: column; gap: 16px;
    }
    .mantine-button { 
      display: inline-flex; align-items: center; justify-content: center; 
      padding: 8px 16px; border: 1px solid #007bff; border-radius: 4px; 
      background-color: #007bff; color: white; text-decoration: none; 
      cursor: pointer; transition: background-color 0.2s;
      font-size: 16px; font-weight: 500;
    }
    .mantine-button:hover { background-color: #0056b3; }
    .mantine-card { 
      background: white; border-radius: 8px; padding: 16px; 
      box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 16px; 
    }
    .mantine-title { 
      margin: 0 0 16px 0; font-size: 24px; font-weight: 600; color: #333; 
    }
    .mantine-text-input { 
      margin-bottom: 16px; 
    }
    .mantine-text-input input { 
      width: 100%; padding: 8px 12px; border: 1px solid #ddd; 
      border-radius: 4px; font-size: 16px; 
    }
    .mantine-simple-grid {
      display: grid; gap: 16px;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    }
    .room-card {
      background: white; border-radius: 8px; padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: transform 0.2s, box-shadow 0.2s;
      cursor: pointer;
    }
    .room-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .room-name {
      font-size: 18px; font-weight: 600; color: #333;
      margin-bottom: 8px;
    }
    .room-id {
      font-size: 14px; color: #666;
      margin-bottom: 8px;
    }
    .inspection-status {
      font-size: 14px; padding: 4px 8px;
      border-radius: 4px; display: inline-block;
    }
    /* スタイル読み込み状態の管理 */
    .styles-loading { 
      opacity: 0.3; 
      transition: opacity 0.3s ease-in-out; 
    }
    .styles-loaded { 
      opacity: 1; 
    }
  </style>
  
  <!-- 重要: CSS ファイルを最初に読み込む (レンダリングブロッキング) -->
  <link rel="stylesheet" href="css_styles/room_select.css?v=20250614c">
  <link rel="stylesheet" href="css_styles/pwa-styles.css?v=20250614c">
  
  <!-- CSS プリロード (パフォーマンス向上) -->
  <link rel="preload" href="css_styles/room_select.css?v=20250614c" as="style">
  <link rel="preload" href="css_styles/pwa-styles.css?v=20250614c" as="style">
  
  <!-- ReactとReactDOMのCDN -->
  <script src="https://unpkg.com/react@18/umd/react.development.js?v=20250614c" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js?v=20250614c" crossorigin></script>
    <!-- BabelのCDN (JSXをブラウザで変換するため) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js?v=20250614c"></script>
  
  <!-- PWA Utilities -->
  <script src="/pwa-utils.js?v=20250614c"></script>
</head>
<body>
  <div id="root" class="styles-loading"></div>  
  <script type="text/babel">
    // ===================================
    // 一般ブラウザ向け部屋選択アプリ
    // WOFF SDK依存なし
    // CSS読み込み完了待機機能追加 v20250614c
    // ===================================
    
    console.log('🚀 Room Select App v20250614c - Enhanced Debug Mode');
    console.log('WOFF Status:', typeof woff !== 'undefined' ? '❌ ERROR: WOFF still loaded!' : '✅ WOFF successfully removed');
    
    // CSS読み込み完了を待機する関数（改良版）
    function waitForStylesLoaded() {
      return new Promise((resolve) => {
        let attempts = 0;
        const maxAttempts = 300; // 3秒のタイムアウト
        
        const checkStyles = () => {
          attempts++;
          
          // CSSリンクの存在確認
          const roomStyles = document.querySelector('link[href*="room_select.css"]');
          const pwaStyles = document.querySelector('link[href*="pwa-styles.css"]');
          
          if (!roomStyles || !pwaStyles) {
            console.log(`Room Select: CSSファイル未発見 (${attempts}回目)`);
            if (attempts < maxAttempts) {
              setTimeout(checkStyles, 10);
              return;
            }
          }
          
          // CSSルールの読み込み確認
          let cssLoaded = true;
          try {
            if (roomStyles.sheet) {
              const rules = roomStyles.sheet.cssRules;
              if (!rules || rules.length === 0) cssLoaded = false;
            } else {
              cssLoaded = false;
            }
            
            if (pwaStyles.sheet) {
              const rules = pwaStyles.sheet.cssRules;
              if (!rules || rules.length === 0) cssLoaded = false;
            } else {
              cssLoaded = false;
            }
          } catch (e) {
            cssLoaded = false;
          }
          
          if (!cssLoaded) {
            console.log(`Room Select: CSSルール未読み込み (${attempts}回目)`);
            if (attempts < maxAttempts) {
              setTimeout(checkStyles, 10);
              return;
            }
          }
          
          // 実際のスタイル適用確認
          const testElement = document.createElement('div');
          testElement.className = 'mantine-container';
          testElement.style.position = 'absolute';
          testElement.style.visibility = 'hidden';
          document.body.appendChild(testElement);
          
          const styles = window.getComputedStyle(testElement);
          const hasContainerStyles = (
            styles.maxWidth === '1200px' ||
            styles.padding !== '0px' ||
            styles.margin === '0px auto' ||
            styles.marginLeft === 'auto'
          );
          
          document.body.removeChild(testElement);
          
          if (hasContainerStyles || attempts >= maxAttempts) {
            console.log(`✅ Room Select: CSS読み込み完了 (${attempts}回目, スタイル適用: ${hasContainerStyles})`);
            
            // ルート要素のクラス変更
            const rootElement = document.getElementById('root');
            if (rootElement) {
              rootElement.className = 'styles-loaded';
            }
            
            resolve();
          } else {
            console.log(`Room Select: スタイル未適用 (${attempts}回目)`);
            setTimeout(checkStyles, 10);
          }
        };
        
        checkStyles();
      });
    }
    
    const formatDateForDisplay = (rawDate) => {
      if (!rawDate) return null;
      
      try {
        if (rawDate instanceof Date && !isNaN(rawDate.getTime())) {
          console.log('[room_select] formatDateForDisplay - Date型を処理:', rawDate);
          const month = rawDate.getMonth() + 1;
          const day = rawDate.getDate();
          console.log(`[room_select] formatDateForDisplay - Date型から抽出: ${month}月${day}日`);
          return `${month}月${day}日`;
        }
        
        let dateStr = String(rawDate).trim();
        console.log('[room_select] formatDateForDisplay - 文字列を処理:', dateStr);
        
        const match = dateStr.match(/^(\d{4})[-/](\d{1,2})[-/](\d{1,2})$/);
        if (match) {
          const [, year, month, day] = match;
          const result = `${parseInt(month)}月${parseInt(day)}日`;
          console.log(`[room_select] formatDateForDisplay - 文字列から抽出: ${result}`);
          return result;
        }
        
        const dateObj = new Date(dateStr);
        if (!isNaN(dateObj.getTime())) {
          const month = dateObj.getMonth() + 1;
          const day = dateObj.getDate();
          console.log(`[room_select] formatDateForDisplay - Date変換成功: ${month}月${day}日`);
          return `${month}月${day}日`;
        }
        
        return null;
      } catch (error) {
        console.warn('[room_select] 日付フォーマットエラー:', rawDate, error);
        return null;
      }
    };
    
    const formatInspectionStatus = (rawDate) => {
      console.log('[room_select] formatInspectionStatus 呼び出し - 引数:', rawDate);
      
      const result = (rawDate && rawDate.hasActualReading !== undefined)
        ? (rawDate.hasActualReading
            ? { status: '検針済み', displayDate: formatDateForDisplay(rawDate.rawInspectionDate) }
            : { status: '未検針', displayDate: null })
        : (() => {
            const formattedDate = formatDateForDisplay(rawDate);
            return formattedDate ? 
              { status: '検針済み', displayDate: formattedDate } : 
              { status: '未検針', displayDate: null };
          })();
      
      console.log('[room_select] formatInspectionStatus 結果:', result);
      return result;
    };

    const getJSTDateString = () => {
      const now = new Date();
      const jstOffset = 9 * 60;
      const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
      const jstTime = new Date(utc + (jstOffset * 60000));
      
      const year = jstTime.getFullYear();
      const month = String(jstTime.getMonth() + 1).padStart(2, '0');
      const day = String(jstTime.getDate()).padStart(2, '0');
      
      const jstDateString = `${year}-${month}-${day}`;
      console.log(`[getJSTDateString] String型JST日付生成: ${jstDateString}`);
      return jstDateString;
    };
    
    const RoomSelectApp = () => {
      const [propertyId, setPropertyId] = React.useState(null);
      const [propertyName, setPropertyName] = React.useState('');
      const [rooms, setRooms] = React.useState([]);
      const [loading, setLoading] = React.useState(true);
      const [error, setError] = React.useState(null);
      const [isNavigating, setIsNavigating] = React.useState(false);
      const [navigationMessage, setNavigationMessage] = React.useState('');

      React.useEffect(() => {
        // コンポーネントマウント時にスクロール位置をリセット
        window.scrollTo(0, 0);
        
        // 直接データを読み込み（WOFF初期化なし）
        const loadRoomData = async () => {
          try {
            // sessionStorageから物件情報を取得
            const storedPropertyId = sessionStorage.getItem('selectedPropertyId');
            const storedPropertyName = sessionStorage.getItem('selectedPropertyName');
            
            console.log('[room_select] sessionStorage情報 - propertyId:', storedPropertyId, 'propertyName:', storedPropertyName);

            if (storedPropertyName) {
              setPropertyName(storedPropertyName);
            } else {
              setPropertyName('物件情報なし');
            }

            if (!storedPropertyId) {
              setError('物件IDがありません。物件選択ページから再度アクセスしてください。');
              setLoading(false);
              return;
            }

            setPropertyId(storedPropertyId);

            // 強制リフレッシュのチェック
            const forceRefresh = sessionStorage.getItem('forceRefreshRooms');
            const updatedRoomId = sessionStorage.getItem('updatedRoomId');
            const lastUpdateTime = sessionStorage.getItem('lastUpdateTime');
            
            console.log('[room_select] キャッシュ更新チェック - forceRefresh:', forceRefresh, 'updatedRoomId:', updatedRoomId, 'lastUpdateTime:', lastUpdateTime);

            // 強制リフレッシュの場合：バックエンドから最新データを取得
            if (forceRefresh === 'true') {
              console.log('[room_select] 🔄 強制リフレッシュ実行中 - バックエンドから最新データを取得');
              
              try {
                const latestRooms = await refreshRoomDataFromBackend(storedPropertyId);
                
                if (updatedRoomId) {
                  const updatedRoom = latestRooms.find(room => room.roomId === updatedRoomId || room.id === updatedRoomId);
                  if (updatedRoom) {
                    console.log('[room_select] ✅ 検針完了により更新された部屋:', updatedRoom.roomName || updatedRoom.name, '検針日:', updatedRoom.rawInspectionDate);
                  }
                }
                
                setRooms(latestRooms);
                
                // フラグをクリア
                sessionStorage.removeItem('forceRefreshRooms');
                sessionStorage.removeItem('updatedRoomId');
                sessionStorage.removeItem('lastUpdateTime');
                
                console.log('[room_select] 🎉 強制リフレッシュ完了');
              } catch (refreshError) {
                console.error('[room_select] ❌ 強制リフレッシュ失敗:', refreshError);
                
                // フォールバック：キャッシュから読み込み
                const roomsString = sessionStorage.getItem('selectedRooms');
                if (roomsString) {
                  try {
                    const parsedRooms = JSON.parse(roomsString);
                    setRooms(Array.isArray(parsedRooms) ? parsedRooms : []);
                    console.log('[room_select] 📦 フォールバック：キャッシュから読み込み完了');
                    setError(null);
                  } catch (parseError) {
                    console.error('[room_select] キャッシュデータの解析失敗:', parseError);
                    setRooms([]);
                    setError('キャッシュデータの読み込みに失敗しましたが、継続します。');
                  }
                } else {
                  console.warn('[room_select] キャッシュもない場合は空配列で継続');
                  setRooms([]);
                  setError('部屋情報がありませんが、空の状態で継続します。');
                }
              }
            } 
            // 通常時：統一キャッシュキーから読み込み
            else {
              const roomsString = sessionStorage.getItem('selectedRooms');
              console.log('[room_select] 📦 統一キャッシュキー (selectedRooms) から読み込み - データ長:', roomsString?.length);
              
              if (roomsString) {
                try {
                  const parsedRooms = JSON.parse(roomsString);
                  console.log('[room_select] 🔍 キャッシュデータ詳細:', {
                    type: typeof parsedRooms,
                    isArray: Array.isArray(parsedRooms),
                    length: parsedRooms ? parsedRooms.length : 'no length property',
                    content: parsedRooms
                  });
                  console.log('[room_select] Parsed rooms from unified cache:', Array.isArray(parsedRooms) ? parsedRooms.length : 'not array', '件');
                  setRooms(Array.isArray(parsedRooms) ? parsedRooms : []);
                } catch (e) {
                  console.error('[room_select] sessionStorageから部屋情報の解析に失敗しました:', e);
                  setRooms([]);
                  setError('部屋情報の読み込みに失敗しましたが、空の状態で継続します。');
                }
              } else {
                console.warn('[room_select] 統一キャッシュキーにデータなし - バックエンドから取得を試行');
                
                try {
                  const latestRooms = await refreshRoomDataFromBackend(storedPropertyId);
                  setRooms(latestRooms);
                } catch (fetchError) {
                  console.error('[room_select] バックエンドデータ取得失敗:', fetchError);
                  setRooms([]);
                  setError('部屋情報の取得に失敗しましたが、空の状態で継続します。');
                }
              }
            }
          } catch (error) {
            console.error('[room_select] Error during room data loading:', error);
            
            // エラー発生時でも最低限の状態を保持
            setRooms([]);
            
            // エラーメッセージを設定（但し、致命的ではない場合は継続）
            if (error.message && error.message.includes('部屋データの形式')) {
              console.warn('[room_select] データ形式エラーですが、空配列で継続します:', error.message);
              setError(null);
            } else {
              setError(`部屋情報の読み込みでエラーが発生しました: ${error.message}`);
            }
          } finally {
            // ローディング状態を必ず解除
            console.log('[room_select] ローディング状態を解除します');
            setLoading(false);
          }
        };

        loadRoomData();
      }, []);

      // バックエンドから最新の部屋データを取得する関数
      const refreshRoomDataFromBackend = async (propertyId) => {
        try {
          console.log('[room_select] 🔄 バックエンドから最新データを取得中...', propertyId);
          
          const gasWebAppUrl = sessionStorage.getItem('gasWebAppUrl');
          if (!gasWebAppUrl) {
            throw new Error('GAS Web AppのURLが設定されていません');
          }

          const requestUrl = `${gasWebAppUrl}?action=getRooms&propertyId=${encodeURIComponent(propertyId)}`;
          const response = await fetch(requestUrl, { method: 'GET' });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const result = await response.json();
          console.log('[room_select] バックエンドレスポンス:', result);
          
          if (result.error) {
            throw new Error(result.error);
          }

          // 統一レスポンス判定処理
          let roomsData = [];
          console.log('[room_select] 🔍 レスポンス形式判定開始');
          console.log('[room_select] レスポンス詳細:', {
            type: typeof result,
            isNull: result === null,
            isUndefined: result === undefined,
            hasSuccess: result && typeof result === 'object' && 'success' in result,
            successValue: result?.success,
            successType: typeof result?.success,
            hasData: result && typeof result === 'object' && 'data' in result,
            dataValue: result?.data,
            dataType: typeof result?.data,
            isDataArray: Array.isArray(result?.data),
            isDirectArray: Array.isArray(result),
            hasRooms: result && typeof result === 'object' && 'rooms' in result,
            roomsValue: result?.rooms,
            isRoomsArray: Array.isArray(result?.rooms)
          });

          // パターン1: 統一形式 {success: true, data: []}
          if (result && 
              typeof result === 'object' && 
              result !== null && 
              result.success === true && 
              result.data && 
              Array.isArray(result.data)) {
            roomsData = result.data;
            console.log('[room_select] ✅ 統一形式採用 - データ件数:', roomsData.length);
          }
          // パターン2: 直接配列
          else if (Array.isArray(result)) {
            roomsData = result;
            console.log('[room_select] ⚠️ 直接配列形式採用 - データ件数:', roomsData.length);
          }
          // パターン3: rooms プロパティ
          else if (result && 
                   typeof result === 'object' && 
                   result !== null && 
                   result.rooms && 
                   Array.isArray(result.rooms)) {
            roomsData = result.rooms;
            console.log('[room_select] ⚠️ rooms形式採用 - データ件数:', roomsData.length);
          }
          // パターン4: 空のレスポンスでも継続処理
          else if (result && typeof result === 'object' && result !== null) {
            // レスポンスはあるが、予期された形式ではない場合
            console.warn('[room_select] ⚠️ 予期しない形式だが空配列で継続:', result);
            roomsData = [];
          }
          // パターン5: 完全に無効なレスポンス
          else {
            console.error('[room_select] ❌ 完全に無効なレスポンス:', result);
            roomsData = [];
          }

          console.log('[room_select] 最終採用データ:', roomsData.length, '件');

          console.log('[room_select] ✅ 最新データ取得完了:', roomsData.length, '件');
          
          // 統一キャッシュキーで保存
          sessionStorage.setItem('selectedRooms', JSON.stringify(roomsData));
          console.log('[room_select] 📦 統一キャッシュキー (selectedRooms) で保存完了');
          
          return roomsData;
          
        } catch (error) {
          console.error('[room_select] ❌ バックエンドデータ取得エラー:', error);
          // エラー時でも空配列を返して処理を継続
          console.warn('[room_select] エラー時は空配列を返して処理を継続します');
          return [];
        }
      };

      const handleBackToPropertySelect = () => {
        setIsNavigating(true);
        setNavigationMessage('画面を切り替えています...');
        // スクロール位置をリセットしてから遷移
        window.scrollTo(0, 0);
        window.location.href = 'property_select.html';
      };

      // LoadingOverlayコンポーネント
      const LoadingOverlay = ({ message }) => (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          backgroundColor: 'rgba(255, 255, 255, 0.95)',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          alignItems: 'center',
          zIndex: 50000,
        }}>
          <div style={{
            width: '40px',
            height: '40px',
            border: '4px solid #f3f3f3',
            borderTop: '4px solid #3498db',
            borderRadius: '50%',
            animation: 'spin 1s linear infinite',
          }} />
          <p style={{
            marginTop: '16px',
            color: '#666',
            fontSize: '14px',
            textAlign: 'center',
          }}>
            {message}
          </p>
          <style>
            {`
              @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
              }
            `}
          </style>
        </div>
      );

      const handleRoomSelect = (room) => {
        if (!propertyId || !propertyName || !room) {
          console.error('[room_select] Invalid data for room selection:', { propertyId, propertyName, room });
          alert('選択された部屋情報が無効です。');
          return;
        }

        setIsNavigating(true);
        setNavigationMessage('検針画面に移動しています...');
        
        // スクロール位置をリセットしてから遷移
        window.scrollTo(0, 0);

        // meter_reading.html に物件ID、物件名、部屋ID、部屋名を渡して画面遷移
        const params = new URLSearchParams();
        params.append('propertyId', propertyId);
        params.append('propertyName', propertyName);
        params.append('roomId', room.id);
        params.append('roomName', room.name);
        
        const targetUrl = `meter_reading.html?${params.toString()}`;
        
        console.log(`[room_select] Redirecting to: ${targetUrl}`);
        window.location.href = targetUrl;
      };

      const handleInspectionComplete = async () => {
        if (!propertyId) {
          alert('物件IDが見つかりません。');
          return;
        }

        try {
          setLoading(true);

          // sessionStorageからGAS URLを取得（property_select.htmlで設定されている）
          const gasWebAppUrl = sessionStorage.getItem('gasWebAppUrl');
          
          if (!gasWebAppUrl) {
            alert('エラー: GAS Web AppのURLが設定されていません。物件選択ページから再度アクセスしてください。');
            console.error('[room_select] gasWebAppUrlがsessionStorageから取得できませんでした。');
            setLoading(false);
            return;
          }
          
          const requestUrl = `${gasWebAppUrl}?action=updateInspectionComplete&propertyId=${encodeURIComponent(propertyId)}`;

          console.log('[room_select] 検針完了リクエスト送信 (GET方式):', {
            url: requestUrl,
            propertyId: propertyId
          });

          const response = await fetch(requestUrl, {
            method: 'GET'
          });

          const result = await response.json();

          if (result.error) {
            throw new Error(result.error);
          }

          alert('検針完了日を更新しました。');
          
        } catch (error) {
          console.error('[room_select] 検針完了処理エラー:', error);
          alert(`検針完了処理でエラーが発生しました: ${error.message}`);
        } finally {
          setLoading(false);
        }
      };

      // データ読み込み中
      if (loading) {
        return (
          <div className="mantine-container">
            <div className="mantine-stack">
              <button
                onClick={handleBackToPropertySelect}
                className="mantine-button variant-outline"
              >
                物件選択へ戻る
              </button>
              <h1 className="mantine-title">部屋選択</h1>
              <p className="mantine-subtitle">物件名：読み込み中...</p>
              <div className="mantine-center">
                <div className="mantine-stack center">
                  <div className="mantine-loader"></div>
                  <p className="mantine-text">部屋情報を読み込み中です...</p>
                </div>
              </div>
            </div>
          </div>
        );
      }

      // エラー時の表示
      if (error) {
        return (
          <div className="mantine-container">
            <div className="mantine-stack">
              <button
                onClick={handleBackToPropertySelect}
                className="mantine-button variant-outline"
              >
                物件選択へ戻る
              </button>
              <h1 className="mantine-title">部屋選択</h1>
              <p className="mantine-subtitle">物件名：{propertyName}</p>
              <div className="mantine-alert">
                <h3 className="mantine-text weight-600">エラー</h3>
                <p className="mantine-text">{error}</p>
              </div>
            </div>
          </div>
        );
      }

      return (
        <div className="mantine-container">
          {isNavigating && <LoadingOverlay message={navigationMessage} />}
          <div className="mantine-stack">
            <button
              onClick={handleBackToPropertySelect}
              className="mantine-button variant-outline"
            >
              物件選択へ戻る
            </button>
            <h1 className="mantine-title">部屋選択</h1>
            <p className="mantine-subtitle">物件名：{propertyName}</p>
            
            <button
              onClick={handleInspectionComplete}
              disabled={loading}
              className="mantine-button variant-filled inspection-complete-btn"
            >
              {loading ? '更新中...' : '検針完了'}
            </button>

            {!Array.isArray(rooms) && (
              <div className="mantine-alert">
                <h3 className="mantine-text weight-600">エラー</h3>
                <p className="mantine-text">部屋データの形式が正しくありません。</p>
              </div>
            )}
            
            {Array.isArray(rooms) && rooms.length === 0 && (
              <p className="mantine-text center">この物件に登録されている部屋はありません。</p>
            )}

            {Array.isArray(rooms) && rooms.length > 0 && (
              <div className="mantine-stack">
                {rooms.map(room => {
                  // デバッグ: 各部屋の生データを出力
                  console.log('[room_select] 部屋データ処理:', {
                    roomId: room.id,
                    name: room.name,
                    rawInspectionDate: room.rawInspectionDate,
                    hasActualReading: room.hasActualReading,
                    rawInspectionDateType: typeof room.rawInspectionDate
                  });
                  
                  // 分離アーキテクチャ: フォーマット関数を使用
                  const displayName = room.name || room.roomName || '部屋名未設定';
                  // hasActualReadingを優先的に使う
                  const inspectionStatus = formatInspectionStatus({
                    rawInspectionDate: room.rawInspectionDate,
                    hasActualReading: room.hasActualReading
                  });

                  // 検針済みの場合は日付のみを表示、未検針の場合は[未検針]
                  let statusDisplay = null;
                  if (inspectionStatus.status === '検針済み' && inspectionStatus.displayDate) {
                    statusDisplay = (
                      <span style={{
                        color: 'var(--mantine-color-blue-6)',
                        fontWeight: '500',
                        fontSize: '0.9em',
                        marginLeft: '8px'
                      }}>
                        [検針日：{inspectionStatus.displayDate}]
                      </span>
                    );
                  } else if (inspectionStatus.status === '検針済み' && !inspectionStatus.displayDate) {
                    // 検針済みだが日付がない場合も[検針済み]と表示
                    statusDisplay = (
                      <span style={{
                        color: 'var(--mantine-color-blue-6)',
                        fontWeight: '500',
                        fontSize: '0.9em',
                        marginLeft: '8px'
                      }}>
                        [検針済み]
                      </span>
                    );
                  } else if (inspectionStatus.status === '未検針') {
                    statusDisplay = (
                      <span style={{
                        color: 'var(--mantine-color-red-6)',
                        fontWeight: '600',
                        fontSize: '0.9em',
                        marginLeft: '8px'
                      }}>
                        [未検針]
                      </span>
                    );
                  }
                  
                  return (
                    <div key={room.id} className="mantine-paper">
                      <button
                        onClick={() => handleRoomSelect(room)}
                        disabled={loading || isNavigating}
                        className="room-card"
                      >
                        <div className="room-info">
                          <div className="room-header">
                            <span className="room-number">
                              {displayName}
                              {/* 分離アーキテクチャ: フォーマット済み検針状況を表示 */}
                              {statusDisplay}
                            </span>
                          </div>
                        </div>
                        <svg className="room-arrow" fill="currentColor" viewBox="0 0 20 20">
                          <path fillRule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clipRule="evenodd" />
                        </svg>
                      </button>
                    </div>
                  );
                })}
              </div>
            )}
          </div>
        </div>
      );
    };

    // CSS読み込み完了後にアプリを起動
    waitForStylesLoaded().then(() => {
      // Use React 18 createRoot API instead of ReactDOM.render
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<RoomSelectApp />);
      console.log('🎨 部屋選択アプリ起動: CSS読み込み完了後に実行');
    });
  </script>
  
  <!-- PWA初期化スクリプト -->
  <script>
    // PWA機能の初期化
    document.addEventListener('DOMContentLoaded', () => {
      console.log('[PWA] Room Select page loaded with PWA support (Browser version)');
      
      // Service Worker登録
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/service-worker.js')
            .then(registration => {
              console.log('[PWA] Service Worker registered from room select page');
            })
            .catch(error => {
              console.error('[PWA] Service Worker registration failed:', error);
            });
        });
      }
      
      // PWAインストール状態の確認
      if (window.pwaUtils) {
        const appInfo = window.pwaUtils.getAppInfo();
        console.log('[PWA] App info:', appInfo);
        
        // インストール済みの場合、UI調整
        if (appInfo.isInstalled) {
          document.body.classList.add('pwa-installed');
        }
        
        // オフライン状態の場合、警告表示
        if (!appInfo.isOnline) {
          window.pwaUtils.showNetworkStatus('オフライン', 'warning');
        }
      }
    });
  </script>
</body>
</html>