<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV ãƒ‡ãƒ¼ã‚¿æ§‹é€ åˆ†æ</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 20px; 
            background-color: #f5f5f5;
        }
        .analysis-result { 
            background-color: #e8f4fd; 
            border: 1px solid #bee5eb; 
            padding: 15px; 
            margin: 10px 0; 
            border-radius: 5px; 
            font-size: 14px;
            white-space: pre-wrap;
            font-family: monospace;
        }
        .load-button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        .load-button:hover {
            background-color: #0056b3;
        }
        table { 
            border-collapse: collapse; 
            width: 100%; 
            margin: 20px 0;
            background-color: white;
            font-size: 12px;
        }
        th, td { 
            border: 1px solid #ddd; 
            padding: 4px; 
            text-align: left;
        }
        th { 
            background-color: #f2f2f2; 
            position: sticky;
            top: 0;
        }
        .highlight { background-color: #fffacd; }
    </style>
</head>
<body>
    <h1>ğŸ“Š CSV ãƒ‡ãƒ¼ã‚¿æ§‹é€ åˆ†æ</h1>
    
    <input type="file" id="csvFileInput" accept=".csv" style="margin-bottom: 10px;">
    <button class="load-button" onclick="loadAndAnalyzeCSV()">CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’åˆ†æ</button>
    <button class="load-button" onclick="simulateGASProcessing()">GASãƒ­ã‚¸ãƒƒã‚¯ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ</button>

    <div class="analysis-result" id="analysis-result">
        CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ã€ŒCSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’åˆ†æã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚
    </div>

    <div id="data-table-container" style="max-height: 400px; overflow: auto;">
        <!-- ãƒ‡ãƒ¼ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ -->
    </div>

    <script>
        let csvData = null;
        let headers = null;

        function loadAndAnalyzeCSV() {
            const fileInput = document.getElementById('csvFileInput');
            const file = fileInput.files[0];

            if (!file) {
                alert('CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const csvText = e.target.result;
                analyzeCSVStructure(csvText);
            };
            reader.readAsText(file, 'UTF-8');
        }

        function analyzeCSVStructure(csvText) {
            console.log('ğŸ” CSVæ§‹é€ åˆ†æé–‹å§‹');
            
            // CSVãƒ‘ãƒ¼ã‚¹
            const lines = csvText.split('\n').filter(line => line.trim() !== '');
            csvData = lines.map(line => {
                // ç°¡å˜ãªCSVãƒ‘ãƒ¼ã‚¹ï¼ˆã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã€å¼•ç”¨ç¬¦ã¯è€ƒæ…®ã—ãªã„ï¼‰
                return line.split(',').map(cell => cell.trim());
            });

            if (csvData.length === 0) {
                document.getElementById('analysis-result').textContent = 'CSVãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™ã€‚';
                return;
            }

            headers = csvData[0];
            const dataRows = csvData.slice(1);

            let analysis = `=== ğŸ“Š CSVæ§‹é€ åˆ†æçµæœ ===\n`;
            analysis += `ãƒ•ã‚¡ã‚¤ãƒ«å: ${document.getElementById('csvFileInput').files[0].name}\n`;
            analysis += `ç·è¡Œæ•°: ${csvData.length} (ãƒ˜ãƒƒãƒ€ãƒ¼1è¡Œ + ãƒ‡ãƒ¼ã‚¿${dataRows.length}è¡Œ)\n`;
            analysis += `ç·åˆ—æ•°: ${headers.length}\n\n`;

            // ãƒ˜ãƒƒãƒ€ãƒ¼åˆ†æ
            analysis += `=== ãƒ˜ãƒƒãƒ€ãƒ¼åˆ†æ ===\n`;
            headers.forEach((header, index) => {
                analysis += `åˆ—[${index}]: "${header}" (é•·ã•: ${header.length})\n`;
            });

            // é‡è¦ãªåˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç¢ºèª
            const importantColumns = [
                'ç‰©ä»¶å', 'ç‰©ä»¶ID', 'éƒ¨å±‹ID', 'æ¤œé‡æ—¥æ™‚', 
                'ä»Šå›ã®æŒ‡ç¤ºæ•°', 'å‰å›æŒ‡ç¤ºæ•°', 'å‰ã€…å›æŒ‡ç¤ºæ•°', 'å‰ã€…ã€…å›æŒ‡ç¤ºæ•°',
                'ä»Šå›ä½¿ç”¨é‡', 'è­¦å‘Šãƒ•ãƒ©ã‚°', 'å†™çœŸURL'
            ];

            analysis += `\n=== é‡è¦åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç¢ºèª ===\n`;
            importantColumns.forEach(colName => {
                const index = headers.indexOf(colName);
                analysis += `ã€Œ${colName}ã€: ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ ${index} ${index === -1 ? 'âŒ è¦‹ã¤ã‹ã‚‰ãš' : 'âœ… å­˜åœ¨'}\n`;
            });

            // å‰ã€…ã€…å›æŒ‡ç¤ºæ•°ã®ç‰¹åˆ¥åˆ†æ
            const threeTimesPreviousIndex = headers.indexOf('å‰ã€…ã€…å›æŒ‡ç¤ºæ•°');
            analysis += `\n=== å‰ã€…ã€…å›æŒ‡ç¤ºæ•° ç‰¹åˆ¥åˆ†æ ===\n`;
            analysis += `åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹: ${threeTimesPreviousIndex}\n`;

            if (threeTimesPreviousIndex !== -1) {
                analysis += `âœ… å‰ã€…ã€…å›æŒ‡ç¤ºæ•°åˆ—ãŒå­˜åœ¨ã—ã¾ã™\n`;
                analysis += `ã“ã®åˆ—ã®ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ï¼ˆæœ€åˆã®5è¡Œï¼‰:\n`;
                for (let i = 0; i < Math.min(5, dataRows.length); i++) {
                    const value = dataRows[i][threeTimesPreviousIndex];
                    analysis += `  è¡Œ${i + 2}: "${value}" (é•·ã•: ${String(value).length})\n`;
                }

                // éç©ºã®å€¤ã®æ•°ã‚’æ•°ãˆã‚‹
                let nonEmptyCount = 0;
                let numericCount = 0;
                for (let i = 0; i < dataRows.length; i++) {
                    const value = dataRows[i][threeTimesPreviousIndex];
                    if (value !== null && value !== undefined && String(value).trim() !== '') {
                        nonEmptyCount++;
                        if (!isNaN(parseFloat(value))) {
                            numericCount++;
                        }
                    }
                }
                analysis += `éç©ºã®å€¤: ${nonEmptyCount}/${dataRows.length}è¡Œ\n`;
                analysis += `æ•°å€¤ã¨ã—ã¦è§£æå¯èƒ½: ${numericCount}/${dataRows.length}è¡Œ\n`;
            } else {
                analysis += `âŒ å‰ã€…ã€…å›æŒ‡ç¤ºæ•°åˆ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“\n`;
                analysis += `é¡ä¼¼ã™ã‚‹åˆ—åã‚’æ¤œç´¢:\n`;
                headers.forEach((header, index) => {
                    if (String(header).includes('å‰') || String(header).includes('å›') || String(header).includes('æŒ‡ç¤º')) {
                        analysis += `  [${index}]: "${header}"\n`;
                    }
                });
            }

            // ç‰¹å®šã®ç‰©ä»¶ãƒ»éƒ¨å±‹ã®ãƒ‡ãƒ¼ã‚¿ç¢ºèª
            const propertyIdIndex = headers.indexOf('ç‰©ä»¶ID');
            const roomIdIndex = headers.indexOf('éƒ¨å±‹ID');
            
            if (propertyIdIndex !== -1 && roomIdIndex !== -1) {
                analysis += `\n=== P000001, R000003 ã®ãƒ‡ãƒ¼ã‚¿ç¢ºèª ===\n`;
                const targetRows = dataRows.filter(row => 
                    String(row[propertyIdIndex]).trim() === 'P000001' && 
                    String(row[roomIdIndex]).trim() === 'R000003'
                );
                
                analysis += `ä¸€è‡´ã™ã‚‹è¡Œæ•°: ${targetRows.length}\n`;
                targetRows.forEach((row, index) => {
                    analysis += `è¡Œ${index + 1}:\n`;
                    analysis += `  ç‰©ä»¶ID: "${row[propertyIdIndex]}"\n`;
                    analysis += `  éƒ¨å±‹ID: "${row[roomIdIndex]}"\n`;
                    if (threeTimesPreviousIndex !== -1) {
                        analysis += `  å‰ã€…ã€…å›æŒ‡ç¤ºæ•°: "${row[threeTimesPreviousIndex]}"\n`;
                    }
                    analysis += `---\n`;
                });
            }

            document.getElementById('analysis-result').textContent = analysis;

            // ãƒ‡ãƒ¼ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«è¡¨ç¤º
            displayDataTable();

            console.log('âœ… CSVæ§‹é€ åˆ†æå®Œäº†');
        }

        function displayDataTable() {
            if (!csvData || csvData.length === 0) return;

            const container = document.getElementById('data-table-container');
            const table = document.createElement('table');
            
            // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œ
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            headers.forEach((header, index) => {
                const th = document.createElement('th');
                th.textContent = `[${index}] ${header}`;
                if (header === 'å‰ã€…ã€…å›æŒ‡ç¤ºæ•°') {
                    th.className = 'highlight';
                }
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            // ãƒ‡ãƒ¼ã‚¿è¡Œ
            const tbody = document.createElement('tbody');
            const dataRows = csvData.slice(1);
            dataRows.slice(0, 10).forEach((row, rowIndex) => { // æœ€åˆã®10è¡Œã®ã¿è¡¨ç¤º
                const tr = document.createElement('tr');
                row.forEach((cell, cellIndex) => {
                    const td = document.createElement('td');
                    td.textContent = cell;
                    if (headers[cellIndex] === 'å‰ã€…ã€…å›æŒ‡ç¤ºæ•°') {
                        td.className = 'highlight';
                    }
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);

            container.innerHTML = '<h3>ğŸ“‹ ãƒ‡ãƒ¼ã‚¿ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆæœ€åˆã®10è¡Œï¼‰</h3>';
            container.appendChild(table);
        }

        function simulateGASProcessing() {
            if (!csvData || !headers) {
                alert('ã¾ãšCSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„ã€‚');
                return;
            }

            console.log('ğŸ¯ GASãƒ­ã‚¸ãƒƒã‚¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹');

            // GASã®getMeterReadingsãƒ­ã‚¸ãƒƒã‚¯ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
            const propertyId = 'P000001';
            const roomId = 'R000003';

            const propertyIdColIndex = headers.indexOf('ç‰©ä»¶ID');
            const roomIdColIndex = headers.indexOf('éƒ¨å±‹ID');
            const dateColIndex = headers.indexOf('æ¤œé‡æ—¥æ™‚');
            const currentReadingColIndex = headers.indexOf('ä»Šå›ã®æŒ‡ç¤ºæ•°');
            const previousReadingColIndex = headers.indexOf('å‰å›æŒ‡ç¤ºæ•°');
            const previousPreviousReadingColIndex = headers.indexOf('å‰ã€…å›æŒ‡ç¤ºæ•°');
            const threeTimesPreviousReadingColIndex = headers.indexOf('å‰ã€…ã€…å›æŒ‡ç¤ºæ•°');
            const usageColIndex = headers.indexOf('ä»Šå›ä½¿ç”¨é‡');
            const statusColIndex = headers.indexOf('è­¦å‘Šãƒ•ãƒ©ã‚°');

            let simulation = `=== ğŸ¯ GASå‡¦ç†ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ ===\n`;
            simulation += `å¯¾è±¡: ç‰©ä»¶ID=${propertyId}, éƒ¨å±‹ID=${roomId}\n\n`;

            simulation += `åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç¢ºèª:\n`;
            simulation += `  ç‰©ä»¶ID: ${propertyIdColIndex}\n`;
            simulation += `  éƒ¨å±‹ID: ${roomIdColIndex}\n`;
            simulation += `  æ¤œé‡æ—¥æ™‚: ${dateColIndex}\n`;
            simulation += `  ä»Šå›ã®æŒ‡ç¤ºæ•°: ${currentReadingColIndex}\n`;
            simulation += `  å‰å›æŒ‡ç¤ºæ•°: ${previousReadingColIndex}\n`;
            simulation += `  å‰ã€…å›æŒ‡ç¤ºæ•°: ${previousPreviousReadingColIndex}\n`;
            simulation += `  å‰ã€…ã€…å›æŒ‡ç¤ºæ•°: ${threeTimesPreviousReadingColIndex}\n`;
            simulation += `  ä»Šå›ä½¿ç”¨é‡: ${usageColIndex}\n`;
            simulation += `  è­¦å‘Šãƒ•ãƒ©ã‚°: ${statusColIndex}\n\n`;

            // ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            const dataRows = csvData.slice(1);
            const filteredData = dataRows.filter(row => 
                String(row[propertyIdColIndex]).trim() === propertyId && 
                String(row[roomIdColIndex]).trim() === roomId
            );

            simulation += `ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°çµæœ: ${filteredData.length}è¡ŒãŒä¸€è‡´\n\n`;

            // å„è¡Œã‚’readingObjectã«å¤‰æ›
            const getDateValue = (index, row) => (index !== -1 && row[index] !== undefined && row[index] !== null) ? String(row[index]).trim() : null;

            const readings = filteredData.map((row, filteredIndex) => {
                let threeTimesPreviousValue = null;
                if (threeTimesPreviousReadingColIndex !== -1) {
                    const rawValue = row[threeTimesPreviousReadingColIndex];
                    simulation += `è¡Œ${filteredIndex + 1}ã®å‰ã€…ã€…å›æŒ‡ç¤ºæ•° raw: "${rawValue}" (å‹: ${typeof rawValue})\n`;
                    
                    if (rawValue !== undefined && rawValue !== null && String(rawValue).trim() !== '') {
                        threeTimesPreviousValue = String(rawValue).trim();
                        simulation += `  â†’ å‡¦ç†å¾Œ: "${threeTimesPreviousValue}"\n`;
                    } else {
                        simulation += `  â†’ ç©ºã®ãŸã‚ null\n`;
                    }
                } else {
                    simulation += `è¡Œ${filteredIndex + 1}: å‰ã€…ã€…å›æŒ‡ç¤ºæ•°åˆ—ãŒå­˜åœ¨ã—ãªã„ãŸã‚ null\n`;
                }

                return {
                    date: getDateValue(dateColIndex, row),
                    currentReading: getDateValue(currentReadingColIndex, row),
                    previousReading: getDateValue(previousReadingColIndex, row),
                    previousPreviousReading: getDateValue(previousPreviousReadingColIndex, row),
                    threeTimesPrevious: threeTimesPreviousValue,
                    usage: getDateValue(usageColIndex, row),
                    status: getDateValue(statusColIndex, row)
                };
            });

            simulation += `\n=== ç”Ÿæˆã•ã‚ŒãŸreadingã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ===\n`;
            readings.forEach((reading, index) => {
                simulation += `èª­ã¿å–ã‚Š${index + 1}:\n`;
                simulation += `  date: "${reading.date}"\n`;
                simulation += `  currentReading: "${reading.currentReading}"\n`;
                simulation += `  previousReading: "${reading.previousReading}"\n`;
                simulation += `  previousPreviousReading: "${reading.previousPreviousReading}"\n`;
                simulation += `  threeTimesPrevious: "${reading.threeTimesPrevious}"\n`;
                simulation += `  usage: "${reading.usage}"\n`;
                simulation += `  status: "${reading.status}"\n`;
                simulation += `---\n`;
            });

            // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ç”Ÿæˆ
            const debugInfo = {
                detectedHeaders: headers,
                headerCount: headers.length,
                threeTimesPreviousIndex: threeTimesPreviousReadingColIndex,
                threeTimesPreviousExists: threeTimesPreviousReadingColIndex !== -1,
                totalDataRows: dataRows.length,
                filteredReadings: readings.length,
                sampleReadingData: readings.length > 0 ? {
                    firstReading: readings[0],
                    lastReading: readings[readings.length - 1],
                    hasThreeTimesPrevious: readings.some(r => r.threeTimesPrevious !== null && r.threeTimesPrevious !== undefined && r.threeTimesPrevious !== ''),
                    threeTimesPreviousValues: readings.map(r => r.threeTimesPrevious).filter(v => v !== null && v !== undefined && v !== ''),
                    threeTimesPreviousCount: readings.filter(r => r.threeTimesPrevious !== null && r.threeTimesPrevious !== undefined && r.threeTimesPrevious !== '').length
                } : null
            };

            simulation += `\n=== ç”Ÿæˆã•ã‚Œã‚‹ãƒ‡ãƒãƒƒã‚°æƒ…å ± ===\n`;
            simulation += `hasThreeTimesPrevious: ${debugInfo.sampleReadingData?.hasThreeTimesPrevious}\n`;
            simulation += `threeTimesPreviousCount: ${debugInfo.sampleReadingData?.threeTimesPreviousCount}\n`;
            simulation += `threeTimesPreviousValues: ${JSON.stringify(debugInfo.sampleReadingData?.threeTimesPreviousValues)}\n`;

            document.getElementById('analysis-result').textContent = simulation;

            console.log('âœ… GASå‡¦ç†ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†');
            console.log('Generated readings:', readings);
            console.log('Generated debugInfo:', debugInfo);
        }
    </script>
</body>
</html>
